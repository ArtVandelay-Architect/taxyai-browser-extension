from bs4 import BeautifulSoup
import json

# Stores a "template", a tree of JsonNodes that represent
# part of the DOM with a unique hash value
class PossibleTemplate:
	def __init__(self, hash, nodes, depth):
		self.hash = hash #String of hash value
		self.nodes = nodes #List of JsonNodes
		self.depth = depth #Number

class OptimizedTemplate(PossibleTemplate):
	def __init__(self, hash, nodes, depth, label, template, valuesToInline):
		super().__init__(hash, nodes, depth)
		self.label = label #string
		self.template = template #string
		self.valuesToInline = valuesToInline #Set of number

class JsonNode:
	#A JsonNode can either be an element or a text
	def __init__(self, type, 
	      tagName, attributes, children, templateHash, templateValues, depth,
		  content):
		self.type = type
		#Type element:
		self.tagName = tagName #String
		self.attributes = attributes #dictionary of string:string
		self.children = children #List of JsonNode
		self.templateHash = templateHash #String
		self.templateValues = templateValues #List of string
		self.depth = depth #Number
		#Type text
		self.content = content #String

	@classmethod #Construct an element type
	def typeElement(cls, 
		 tagName, attributes, children, templateHash, templateValues, depth):
		return cls("ELEMENT", 
	     tagName, attributes, children, templateHash, templateValues, depth, "")
	
	@classmethod #Construct a text type
	def typeText(cls, 
		 content, templateHash, templateValues, depth):
		return cls("TEXT", 
	     "", {}, [], templateHash, templateValues, depth, content)
		


# Takes in a simplified HTML 
# (generated by taking the original HTML, convert to DOM, and simplify the DOM,
# and convert back to HTML) 
# as a string, 
# and return the string of a templatized version of the HTML
def templatize(htmlString): 
	#Convert the html to DOM again 
	#(might be able to simplify this step in currentTask.ts)
	domRoot = BeautifulSoup(htmlString, "html.parser")

	possibleTemplates = {} #A dictionary of string:possibleTemplate

	tree = findPotentialTemplates(domRoot, possibleTemplates)
	if (tree is None): #No room for optimisation
		return htmlString
	
	optimizedTemplates = {} #A dictionary of string:optimizedTemplate
	for template in possibleTemplates.values():
		optimized = optimizeTemplate(template)
		optimizedTemplates[optimized.hash] = optimized
	
	#Another dictionary of string:optimizedTemplate
	chosenTemplates = chooseTemplates(optimizedTemplates)

	printedTemplates = []
	for oTemplate in chosenTemplates.values():
		printedTemplates.append(oTemplate.label + ":" + oTemplate.template)
	"\n".join(printedTemplates)

	templatizedTree = serializeTree(tree)

	return printedTemplates + "\n\n" + templatizedTree

	
# Recursively find out all the possible templates with root at `node`
# Returns the JsonNode of root
def findPotentialTemplates(node, possibleTemplates):
	#If the node is a Tag AKA Element
	if (type(node) == BeautifulSoup.Tag):
		#Fill the Attributes of the node
		attributes = node.attrs

		#Fill the children of the node with JsonNode format of children
		children = []
		for child in node.children:
			childJson = findPotentialTemplates(child, possibleTemplates)
			if (childJson):
				children.append(childJson)
		
		#Depth is the largest depth amongst the children, plus 1
		depth = max(children, key = lambda c:c.depth).depth + 1

		#Create a hash value using the following components
		attributeKeyList = list(attributes.keys()).sort()
		childrenHashList = [child.templateHash for child in children].sort()
		templateHash = node.name + "|".join(attributeKeyList) +  \
			"|".join(childrenHashList)
		
		#Create a list of values of the attributes
		attributeValList = list(attributes.values()).sort()
		childrenValList = [value \
			 for value in child.templateValues \
			   for child in children].sort()
		templateValues = attributeValList + childrenValList

		jsonNode = JsonNode.typeElement( #create a JsonNode of element type
				node.name, 
				attributes, 
				children, 
				templateHash, 
				templateValues, 
				depth
			)
		
		#If there exist a template with identical hash
		if (possibleTemplates[templateHash]): 
			if (possibleTemplates[templateHash].depth != depth):
				quit() #Find a way to handle this error
			possibleTemplates[templateHash].nodes.append(jsonNode)
		else: #Else, create the template
			possibleTemplates[templateHash] = PossibleTemplate(
				templateHash, 
				[jsonNode], 
				depth
			)
	#Type is navigable string AKA Text
	elif (type(node) == BeautifulSoup.String):
			text = unicode(node)
			#If the text is not empty and not just white spaces
			if (text and text.strip()): 
				#Simply return, since there is no text children
				return JsonNode.typeText(text, "TEXT", [text], 0)
	#Else
	return None
	
# Takes a `PossibleTemplate` and return an `OptimizedTemplate`
def optimizeTemplate(template):
	valuesToInline = {}
	templateRootValuesLength = len(template.nodes[0].templateValues)
	#Go through 0 to templateRootValuesLength - 1, AKA all Values from root
	for i in range(templateRootValuesLength):
		# Get the ith templateValue for all children 
		values = [n.templateValues[i] for n in template.nodes]
		# If any of the value is identical to the value in root, note it down
		if (all(value == values[0] for value in values)):
			valuesToInline.add(i)
	return OptimizedTemplate(template.hash, template.nodes, template.depth, 
			  "", "", valuesToInline) #No label and template yet

# Takes a dictionary of optimizedTemplates indexed by their hash value, 
# Return the templates that are worthy to be used in hash:oTemplates
def chooseTemplates(optimizedTemplates):
	chosenTemplates = {} #string(hash):OptimizedTemplate to store chosen ones
	consumedTemplateCounts = {} #string(hash):number number of occurence 

	#Sort the templates by descending depth
	optimizedTemplates = optimizedTemplates.sort(key = lambda obj:-obj.depth)
	for template in optimizedTemplates.values():
		#Initialise consumedTemplateCounts if not done already
		if consumedTemplateCounts[template.hash] is None:
			consumedTemplateCounts[template.hash] = 0

		#If the template is useful in less than 3 places, skip
		if (len(template.nodes) - consumedTemplateCounts[template.hash] < 3):
			continue
		#If the template is less than 3 place deep, also skip
		if (template.depth < 3):
			continue
		
		#Assign a unique label to the new template in the order it is added
		template.label = "T" + str(len(chosenTemplates.keys())+1)
		serialized = createTemplateTree(template.notes[0],\
				   chosenTemplates, template)
		#Remember template is a string now
		template.template = serialized["template"]
		chosenTemplates[template.hash] = template
		for t in serialized["consumedTemplates"]:
			consumedTemplateCounts[t] = (consumedTemplateCounts[t] or 0)\
				  + len(template.nodes)
			
	return chosenTemplates




# Takes an OptimizedTemplate and a number, return a string as the placeholderIndex
# Used by createTemplateTree()
def getPlaceholder(optimizedTemplate, valueIndex):
	length = 0
	for val in list(optimizedTemplate.valuesToInline):
		if (val < valueIndex):
			length += 1
	placeholderIndex = valueIndex + 1 - length
	return "$" + str(placeholderIndex)

# Takes a JsonNode, a dictionary of OptimizedTemplates (NOT USED????)
# Also takes an OptimizedTemplate and optionally a number
# Returns a dictionary with:
## template: a string representing the serialized template 
## valueIndex: an updated index of the tempValues array
## consumedTemplates: a list of strings with the hashes of consumed templates
def createTemplateTree(node, optimizedTemplates, renderForTemplate, 
		       currentValueIndex = 0):
	if (node.type == "TEXT"): #Type is text
		if (currentValueIndex in renderForTemplate.valuesToInline): #Duplicated
			return {
				"template": node.content,
				"valueIndex": currentValueIndex + 1,
				"consumedTemplates": [node.templateHash]}
		else: #Not duplicated
			return {
				"template": getPlaceholder(
				renderForTemplate, currentValueIndex),
				"valueIndex": currentValueIndex + 1,
				"consumedTemplates": [node.templateHash]}			
	#ELSEIF type == ELEMENT
	updatedValueIndex = currentValueIndex
	consumedTemplates = [node.templateHash]
	
	index = 0
	attrs = []
	for k,v in node.attributes.items():
		if ((updatedValueIndex + 1) in renderForTemplate.valuesToInline):
			attrs.append(" " + str(k) + '''="''' + str(v) + '''"''') #k="v"
		else:
			temp = getPlaceholder(renderForTemplate, updatedValueIndex + index)
			attrs.append(" " + str(k) + '''="''' + str(temp) + '''"''') #k="v"
		index += 1
	attrs = "".join(attrs) #Serialised attributes

	updatedValueIndex += len(node.attributes.keys())

	children = []
	for child in node.children:
		childTemplateTree = createTemplateTree(
			child,
			optimizedTemplates,
			updatedValueIndex
		)
		children.append(childTemplateTree["template"])
		updatedValueIndex = childTemplateTree["valueIndex"]
		consumedTemplates = consumedTemplates + \
			childTemplateTree["consumedTemplates"]
		
	# The HTML format is either
	# <AAA B="C" E="D"/>
	# or <AAA B="C" E="D"> children <AAA/>	
	template = "<" + node.tagName.lower() + attrs
	if (node.children.length == 0): #The leaf of a tree
		template = template + "/>"
	else:
		template = template + ">" + "".join(children) + \
			"</" + node.tagName.lower() + ">"
	return {
		"template": template,
		"valueIndex": updatedValueIndex,
		"consumedTemplates": consumedTemplates
	}

# Takes a JsonNode and a dictionary of string:OptimizedTemplate
# that has been chosen by chooseTemplates
# Serialize all the content and return it as a string
def serializeTree(node, templates):
	if (node.type == "TEXT"):
		return node.content
	#ELSEIF type == "ELEMENT"

	#Check if the nodes hash matches any of the chosen templates
	if (node.templateHash in templates):
		template = templates[node.templateHash]
		templateValues = []
		for i, val in enumerate(node.templateValues):
			if (i not in template.valuesToInline):
				if (val.isnumeric()):
					temp = val
				else:
					temp = json.dumps(val)
				templateValues.append(temp)
		templateValues = ",".join(templateValues)
		return "{" + template.label + "(" + templateValues + ")}"
	
	attrs = ""
	for k,v in node.attributes.items():
		attrs = attrs + " " + str(k) + '="' + v + '"' #k="v"
	
	children = ""
	for child in node.children:
		children = children + serializeTree(child, templates)

	# The HTML format is either
	# <AAA B="C" E="D"/>
	# or <AAA B="C" E="D"> children <AAA/>
	result = "<" + node.tagName.lower + attrs
	if (node.children.length == 0): #The leaf of a tree
		result = result + "/>"
	else:
		result = result + ">" + "".join(children) + \
			"</" + node.tagName.lower() + ">"
	return result		








		

			


